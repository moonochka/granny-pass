# granny-pass
---

## Usage
```shell
go run cmd/granny-pass-dev/main.go
```

## Help
```shell
go run cmd/granny-pass-dev/main.go -h
```

## Tests
```shell
make test
```

## Description
### Задача
"Бабушке нужно сгенерировать пароль, она слышала, что если взять четыре слова из английского словаря, то можно получить хороший вариант. Но проблема в том, что бабушка печатает одним пальцем и перемещать палец по клавиатуре ей затруднительно, поэтому необходимо использовать такие слова, которые эти перемещения минимизируют (считаются перемещения по четырём сторонам, например, от "F" до "H" необходимо выполнить два перемещения, а от "A" до "E" три), при том, что общая длина пароля будет от 20 до 24 символов. Требуется найти наилучший пароль для бабушки."

### Решение
Данный вариант решения не является законченным.

Проект поделен на 2 части: генерация таблицы расстояний между всеми буквами на клавиатуре и вычисление лучшего пароля в зависимости от параметров.

В первой части (graph) структуры данных были подсмотрены в репозитории https://github.com/dominikbraun/graph.
Но он не подходил целиком, что-то было лишнее, а алгоритм Флойда-Уоршелла (WFI) не реализован вообще. Поэтому я скорее вдохновлялась указанным репозиторием (в нем еще используются дженерики, а я раньше с ними не работала, хотелось поиграться, но очевидно, что использование дженериков в графе в данном случае избыточно). Все буквы на клавиатуре являются вершинами графа, а соседние клавиши — ребрами с весом 1. Далее с помощью алгоритма Флойда-Уоршелла (WFI) находится матрица весов путей между всеми вершинами, что соответствует длине пути между всеми возможными биграммами.

Во второй части (processor) используется файл с английскими словами, которые можно использовать для пароля (их загружено несколько, с разным количеством слов, это случайные нарезки из репозитория https://github.com/dwyl/english-words/blob/master/words_alpha.txt). Был реализован классический алгоритм упаковки рюкзака 0-1 (KnapsackTable), который потом модифицировался и дополнялся для решения задачи (KnapsackMinTable). Пароль можно представить в виде рюкзака, ценность предмета — это длина пути на клавиатуре для конкретного слова, а вес предметов — длина слова. Дополнительно учитывается, что слов в пароле возможно только 4, и что длина пути между словами тоже важна. Реализованное решение не является оптимальным, т. к. зависит от порядка слов в файле. Также не гарантируется, что найдется идеальный пароль. Тем не менее результат не плох :)

### Замечания
Мне видится, что при однопальцевом наборе пароля, легко искать все соседние буквы. Поэтому я добавила 2 варианта определения графа: согласно условиям задачи и более естественный (в нем от S до E всего одно перемещение).

### To do list
* улучшить алгоритм (сейчас для упаковки рюкзака слово добавляется только в конец к существующим)
* распараллелить
